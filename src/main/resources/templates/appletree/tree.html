<!doctype html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="/css/button.css" />
  <link rel="stylesheet" href="/css/appletree/tree.css">
  <link rel="stylesheet" href="/css/font.css" />
  <link rel="stylesheet" href="/css/scroll.css" />
</head>
<body class="no-scroll">
 <div class="tree-area">
	<div th:each="apple : ${apples}" class="apple">
	  <a th:href="@{'/appletree/' + ${apple.id}}">
	    <span th:text="${apple.title} ?: '（タイトルなし）'" class="onwhite font3"></span>
	  </a>
	</div>
 </div>

 <div class="fixed-actions">
   <a th:href="@{/appletree/new}" class="btn small ghost plant-btn">シャボン生成</a>
   <a href="/home" class="btn small ghost">ホームへ戻る</a>
 </div>
 
 
 <script>
 document.addEventListener("DOMContentLoaded", () => {
   const area = document.querySelector(".tree-area");
   if (!area) return;

   const links = [...area.querySelectorAll(".apple > a")];
   if (!links.length) return;

   // 設定（好みで調整）
   const PADDING = 14;         // 端の余白
   const MIN_GAP = 55;         // りんご同士の“隙間”の最低値（まばら度）
   const MAX_TRIES = 1500;     // 試行回数（多いほど詰められる）

   // りんごのサイズ（DOMから実測）
   const sample = links[0].getBoundingClientRect();
   const appleW = Math.round(sample.width);
   const appleH = Math.round(sample.height);

   const areaRect = area.getBoundingClientRect();
   const W = Math.floor(areaRect.width);
   const H = Math.floor(areaRect.height);

   const placed = []; // {x,y}

   // 重なり判定：矩形＋余白
   const isOK = (x, y) => {
     for (const p of placed) {
       const overlapX = x < p.x + appleW + MIN_GAP && x + appleW + MIN_GAP > p.x;
       const overlapY = y < p.y + appleH + MIN_GAP && y + appleH + MIN_GAP > p.y;
       if (overlapX && overlapY) return false;
     }
     return true;
   };

   // 乱数
   const rand = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

   // 置ける範囲（りんごがはみ出ないように）
   const minX = PADDING;
   const maxX = Math.max(PADDING, W - appleW - PADDING);
   const minY = PADDING;
   const maxY = Math.max(PADDING, H - appleH - PADDING);

   links.forEach((a) => {
     // いったん左上に寄せて「サイズ確定」させる（環境によって必要）
     a.style.left = "0px";
     a.style.top = "0px";

     let best = null;
     let bestScore = -Infinity;

     for (let i = 0; i < MAX_TRIES; i++) {
       const x = rand(minX, maxX);
       const y = rand(minY, maxY);

       if (!isOK(x, y)) continue;

       // “まばら”にするため、既存のりんごからの最小距離を最大化する点を採用
       let minDist = Infinity;
       for (const p of placed) {
         const dx = (x + appleW/2) - (p.x + appleW/2);
         const dy = (y + appleH/2) - (p.y + appleH/2);
         const d = Math.hypot(dx, dy);
         if (d < minDist) minDist = d;
       }

       const score = (placed.length === 0) ? 999999 : minDist;

       if (score > bestScore) {
         bestScore = score;
         best = { x, y };
       }

       // ある程度良いのが見つかったら早めに確定してもOK
       if (bestScore > 140) break;
     }

     // どうしても入らない場合は重なり許容で置く（極端に多い時の保険）
     const pos = best ?? { x: rand(minX, maxX), y: rand(minY, maxY) };

     a.style.left = `${pos.x}px`;
     a.style.top = `${pos.y}px`;

     placed.push(pos);
   });
 });
 </script>


</body>
</html>